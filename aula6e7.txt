Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:
Resposta:
   unsigned int Raiz_Quadrada(unsigned int S){
        unsigned int interacoes = 15;
        float x0 = S;
        float x;
        int n;
        for(n = 0; n <= interacoes; n++){
            x = (x0 + (S/x0))/2;
            x0 = x;
        }
	return (unsigned int x);
    }

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.
x0 = R13
S = R15
CalculaRaiz: add.w #1,R11    ; calcula div R15/R13 e guarda em R15 --> (R15 = R15/R13)
	     mov.w #0,R12    ; registrador que guarda o "resultado" primário para divisao  		
             mov.w R15,R14   ; copia R15(numerador) para R14(registrador temporario). 
	     jz fimMult	     ; se o numerador for Zero, a divisão termina
looping:     sub.w R13,R14;  ; 
             jn fimDiv	     ; se o valor de SUB R13,R14 for negativo então a divisão termina.
	     cmp.w R14,R15   ; se a divisão for por zero, essa comparação permite terminar a div.
	     jz fimDiv       ; should never happen.
	     add.w #1,R12    ; vai adicionando um valor ao resultado até o resultado final.
	     jmp looping     ; looping para somar repetidas vezes até R12 ser Zero.
fimDiv: 		   
			     ; ------------------------------------------------------- 
	     add.w R13,R12   ; R15 = Xo + (S/Xo)
	     rra.w R12	     ;       -----------
	     mov.w R12,R15   ;            2
	     sub.w #15,R11   ; analisa as 15 interações
	     jn Fim          ; FIM
	     jmp CalculaRaiz ; looping de interações


4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão 
de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' 
são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através 
do registrador R15.


soluçao:

	Calc_Resto:   cmp.w R14, R15; // supondo a e b valores positivos.
		      JL       End;   // pula para retornar a rotina principal	
		      sub.w R14, R15; // subtrai a de b
	       End:   ret             // retorna para funçao principal  




5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x);

soluçao:

		 int ehprimo(int n)
		{
 		 int limite;
                 
		 limite = (int)sqrt(n);// ou usa a funçao do primeiro exercicio.
		// unsigned int Raiz_Quadrada(unsigned int n)
		//limite = x
 		 for(int i=2;i<=limite;i++)
		  {
 		   if(n%i==0) return 0;
		  }
 			 return 1;
		}



6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!.
 Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. 
Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n);

#include <stdio.h>
 
unsigned long long duplofatorial(unsigned long long N)
{
    unsigned long long DF=1;
    int i;
 
    if(N==0)
    {
        return 1;
    }
 
    if(n%2==1)
    {
        for(i=1;i<=N/2;i++)
        {
            DF=DF*(2*i+1);
        }
    }
    else
    {
        for(i=1;i<=N/2;i++)
        {
            DF=DF*2*i;
        }
    }
 
    return DF;
}
 
int main()
{
    unsigned long long n;
    unsigned long long DF;
    printf("Escreva o número: ");
    scanf("%llu",&n);
    DF=duplofatorial(n);
    printf("O super fatorial de %llu é %llu \n",n,DF);


7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);

Soluçao:
#include <stdio.h>
 
double expTaylor(double n)
{
    int i, fat=1;
    double expo=1, po=1;
    for(i=1;i<11;i++)
    {
        fat=fat*i;
        po=po*n;
        expo = expo + po/fat;
    }
    return expo;
}
 
int main()
{
    double N, expo;
    printf("Escreva o número: ");
    scanf("%lf",&N);
    expo = expTaylor(N);
    printf("A exponencial de N e^N é %lf \n",expo);
}




(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de 
entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15,
 e o valor de saída também.




10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

soluçao:

#include <stdio.h>
 
int main()
{
    int v[]={0,10,20,20,10,0};
    int tam;
    tam=sizeof(v)/sizeof(v[0]);
    palindromo(v, tam);
}
 
int palindromo(int v[], int tam)
{
    int i;
    int stop=0;
 
    for(i=0;i<tam/2;i++)
    {
        if(v[i] != v[tam-1-i])
        {
            stop=1;
            break;
        }
    }
 
    if(stop==0)
    {
        printf("O vetor é um palíndromo \n");   
    }
    else
    {
        printf("O vetor não é um palíndromo \n");
    }
}




(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 
O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14,
 e o resultado é dado pelo registrador R15.